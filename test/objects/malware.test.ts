import { ZodError } from "zod";
import {
    Description,
    ExternalReferences,
    Name,
    ObjectMarkingRefs,
    StixCreatedByRef,
    StixCreatedTimestamp,
    StixIdentifier,
    StixModifiedTimestamp,
    StixSpecVersion,
    StixTimestamp,
    StixType,
    XMitreAttackSpecVersion,
    XMitreContributors,
    XMitreDomains,
    XMitreModifiedByRef,
    XMitrePlatforms,
    XMitreVersion,
    stixTypeSchema,
} from "../../src/schemas/common";
import {
    KillChainPhase,
    Malware,
    malwareSchema,
} from "../../src/schemas/sdo/malware.schema";
import { v4 as uuidv4 } from "uuid";

describe("malwareSchema", () => {
    let malwares: any[];

    let minimalMalware: Malware;

    beforeAll(() => {
        malwares = global.attackData.objectsByType["malware"];

        minimalMalware = malwareSchema.parse({
            type: stixTypeSchema.Enum["malware"] as StixType,
            id: `malware--${uuidv4()}` as StixIdentifier,
            spec_version: "2.1" as StixSpecVersion,
            created_by_ref: `identity--${uuidv4()}` as StixCreatedByRef,
            created: "2017-05-31T21:32:29.203Z" as StixCreatedTimestamp,
            modified: "2021-02-09T13:58:23.806Z" as StixModifiedTimestamp,
            name: "HAMMERTOSS" as Name,
            description:
                "[HAMMERTOSS](https://attack.mitre.org/software/S0037) is a backdoor that was used by [APT29](https://attack.mitre.org/groups/G0016) in 2015. (Citation: FireEye APT29) (Citation: F-Secure The Dukes)" as Description,
            external_references: [
                {
                    source_name: "mitre-attack",
                    url: "https://attack.mitre.org/software/S0037",
                    external_id: "S0037",
                },
            ] as ExternalReferences,
            object_marking_refs: [
                "marking-definition--fa42a846-8d90-4e51-bc29-71d5b4802168",
            ] as ObjectMarkingRefs,
            x_mitre_attack_spec_version: "2.1.0" as XMitreAttackSpecVersion,
            x_mitre_domains: ["enterprise-attack"] as XMitreDomains,
            x_mitre_modified_by_ref:
                "identity--c78cb6e5-0c4b-4611-8297-d1b8b55e40b5" as XMitreModifiedByRef,
            is_family: false as Boolean,
            x_mitre_version: "1.2" as XMitreVersion,
        });
    });

    describe("Valid Inputs", () => {
        it("should accept minimal valid object (only required fields)", () => {
            expect(() => malwareSchema.parse(minimalMalware)).not.toThrow();
        });

        it("should accept fully populated valid object (required + optional ATT&CK fields)", () => {
            const fullMalware = {
                ...minimalMalware,
                x_mitre_platforms: ["Windows"] as XMitrePlatforms,
                x_mitre_contributors: ["Contributor"] as XMitreContributors,
                x_mitre_aliases: ["HAMMERTOSS", "HammerDuke", "NetDuke"],
            };
            expect(fullMalware).toBeDefined();
            expect(() => malwareSchema.parse(fullMalware)).not.toThrow();
        });

        it("should accept fully populated valid object (required + optional fields deifined in STIX but not used in ATT&CK)", () => {
            // Test with all fields populated with valid, non-edge-case values
            const fullMalware = {
                ...minimalMalware,
                kill_chain_phases: [
                    {
                        kill_chain_name: "mitre-attack",
                        phase_name: "privilege-escalation",
                    },
                ] as KillChainPhase[],
                x_mitre_platforms: ["Windows"] as XMitrePlatforms,
                x_mitre_contributors: ["Contributor"] as XMitreContributors,
                aliases: ["HAMMERTOSS", "HammerDuke", "NetDuke"],
                first_seen: "2015-07-01T00:00:00.000Z" as StixTimestamp,
                last_seen: "2016-07-01T00:00:00.000Z" as StixTimestamp,
                malware_types: ["remote-access-trojan"],
                os_execution_envs: ["Windows", "Linux"],
                architecture_execution_envs: ["x86"],
                capabilities: ["exfiltrates-data", "accesses-remote-machines"],
                implementation_languages: ["python"],
                // check type for this
                sample_refs: ["tool--a3b8b3b2-4d2f-4a2e-9a1b-1c8b3e4e6f5d"],
            };
            expect(fullMalware).toBeDefined();
            expect(() => malwareSchema.parse(fullMalware)).not.toThrow();
        });
        // Add more valid input tests...
    });

    describe("Field-Specific Tests", () => {
        describe("id", () => {
            it("should reject invalid values", () => {
                const invalidMalware: Malware = {
                    ...minimalMalware,
                    id: "invalid-id" as StixIdentifier,
                } as Malware;
                expect(() => malwareSchema.parse(invalidMalware)).toThrow();
            });

            it("should reject omittance of required values", () => {
                const { id, ...malwareWithoutId } = minimalMalware;
                expect(() => malwareSchema.parse(malwareWithoutId)).toThrow();
            });
        });

        describe("type", () => {
            it("should reject invalid values", () => {
                const invalidMalware: Malware = {
                    ...minimalMalware,
                    type: "invalid-type" as any,
                };
                expect(() => malwareSchema.parse(invalidMalware)).toThrow();
            });

            it("should reject omittance of required values", () => {
                const { type, ...malwareWithoutType } = minimalMalware;
                expect(() => malwareSchema.parse(malwareWithoutType)).toThrow();
            });
        });

        describe("is_family", () => {
            it("should reject invalid values", () => {
                const invalidMalware: Malware = {
                    ...minimalMalware,
                    is_family: "invalid-is-family" as any,
                };
                expect(() => malwareSchema.parse(invalidMalware)).toThrow();
            });

            it("should reject omittance of required values", () => {
                const { is_family, ...malwareWithoutIsFamily } = minimalMalware;
                expect(() => malwareSchema.parse(malwareWithoutIsFamily)).toThrow();
            });
        });

        describe("malware_types", () => {
            it("should reject invalid values", () => {
                const invalidMalware: Malware = {
                    ...minimalMalware,
                    malware_types: ["invalid"] as any,
                };
                expect(() => malwareSchema.parse(invalidMalware)).toThrow();
            });

            it("should accept omittance of optional values", () => {
                const { malware_types, ...malwareWithoutMalwareTypes } = minimalMalware;
                expect(() => malwareSchema.parse(malwareWithoutMalwareTypes)).not.toThrow();
            });
        });

        describe("kill_chain_phases", () => {
            it("should reject invalid values", () => {
                const invalidMalware: Malware = {
                    ...minimalMalware,
                    kill_chain_phases: [{ invalid: "object" }] as any,
                };
                expect(() => malwareSchema.parse(invalidMalware)).toThrow();
            });

            it("should accept omittance of optional values", () => {
                const { kill_chain_phases, ...malwareWithoutKillChainPhases } = minimalMalware;
                expect(() => malwareSchema.parse(malwareWithoutKillChainPhases)).not.toThrow();
            });
        });

        describe("first_seen", () => {
            it("should reject invalid values", () => {
                const invalidMalware: Malware = {
                    ...minimalMalware,
                    first_seen: "2017-05-31" as StixTimestamp,
                };
                expect(() => malwareSchema.parse(invalidMalware)).toThrow();
            });

            it("should accept omittance of optional values", () => {
                const { first_seen, ...malwareWithoutFirstSeen } = minimalMalware;
                expect(() => malwareSchema.parse(malwareWithoutFirstSeen)).not.toThrow();
            });
        });

        describe("last_seen", () => {
            it("should reject invalid values", () => {
                const invalidMalware: Malware = {
                    ...minimalMalware,
                    last_seen: "2017-05-31" as StixTimestamp,
                };
                expect(() => malwareSchema.parse(invalidMalware)).toThrow();
            });

            it("should accept omittance of optional values", () => {
                const { last_seen, ...malwareWithoutLastSeen } = minimalMalware;
                expect(() => malwareSchema.parse(malwareWithoutLastSeen)).not.toThrow();
            });
        });

        describe("os_execution_envs", () => {
            it("should reject invalid values", () => {
                const invalidMalware: Malware = {
                    ...minimalMalware,
                    os_execution_envs: "invalid" as any,
                };
                expect(() => malwareSchema.parse(invalidMalware)).toThrow();
            });

            it("should accept omittance of optional values", () => {
                const { os_execution_envs, ...malwareWithoutOSExecutionEnvs } = minimalMalware;
                expect(() => malwareSchema.parse(malwareWithoutOSExecutionEnvs)).not.toThrow();
            });
        });

        describe("architecture_execution_envs", () => {
            it("should reject invalid values", () => {
                const invalidMalware: Malware = {
                    ...minimalMalware,
                    architecture_execution_envs: ["invalid"] as any,
                };
                expect(() => malwareSchema.parse(invalidMalware)).toThrow();
            });

            it("should accept omittance of optional values", () => {
                const { architecture_execution_envs, ...malwareWithoutArchitectureExecutionEnvs } =
                    minimalMalware;
                expect(() => malwareSchema.parse(malwareWithoutArchitectureExecutionEnvs)).not.toThrow();
            });
        });

        describe("implementation_languages", () => {
            it("should reject invalid values", () => {
                const invalidMalware: Malware = {
                    ...minimalMalware,
                    implementation_languages: ["invalid"] as any,
                };
                expect(() => malwareSchema.parse(invalidMalware)).toThrow();
            });

            it("should accept omittance of optional values", () => {
                const { implementation_languages, ...malwareWithoutImplementationLanguages } =
                    minimalMalware;
                expect(() => malwareSchema.parse(malwareWithoutImplementationLanguages)).not.toThrow();
            });
        });

        describe("capabilities", () => {
            it("should reject invalid values", () => {
                const invalidMalware: Malware = {
                    ...minimalMalware,
                    capabilities: ["invalid"] as any,
                };
                expect(() => malwareSchema.parse(invalidMalware)).toThrow();
            });

            it("should accept omittance of optional values", () => {
                const { capabilities, ...malwareWithoutCapabilities } = minimalMalware;
                expect(() => malwareSchema.parse(malwareWithoutCapabilities)).not.toThrow();
            });
        });

        describe("sample_refs", () => {
            it("should reject invalid values", () => {
                const invalidMalware: Malware = {
                    ...minimalMalware,
                    sample_refs: "invalid-sample-ref" as any,
                };
                expect(() => malwareSchema.parse(invalidMalware)).toThrow();
            });

            it("should accept omittance of optional values", () => {
                const { sample_refs, ...malwareWithoutSampleRefs } = minimalMalware;
                expect(() => malwareSchema.parse(malwareWithoutSampleRefs)).not.toThrow();
            });
        });

        describe('aliases', () => {
            it('should reject invalid values', () => {
                const invalidMalware: Malware = {
                    ...minimalMalware,
                    aliases: 123 as any
                };
                expect(() => malwareSchema.parse(invalidMalware)).toThrow();
            });

            it("should accept omitted optional values", () => {
                const { aliases, ...malwareWithoutAliases } = minimalMalware;
                expect(() => malwareSchema.parse(malwareWithoutAliases)).not.toThrow();
            });
        });

        describe("created_by_ref", () => {
            it("should reject invalid values", () => {
                const invalidMalware: Malware = {
                    ...minimalMalware,
                    created_by_ref: "invalid-created-by-ref" as any,
                };
                expect(() => malwareSchema.parse(invalidMalware)).toThrow();
            });

            it("should reject invalid values", () => {
                const invalidMalware: Malware = {
                    ...minimalMalware,
                    created_by_ref: `malware--${uuidv4()}` as any
                };
                expect(() => malwareSchema.parse(invalidMalware)).toThrow();
            });

            it("should reject omittance of required values", () => {
                const { created_by_ref, ...malwareWithoutCreatedByRef } = minimalMalware;
                expect(() => malwareSchema.parse(malwareWithoutCreatedByRef)).toThrow();
            });
        });

        describe('description', () => {
            it('should reject invalid values', () => {
                const invalidMalware: Malware = {
                    ...minimalMalware,
                    description: 123 as any
                };
                expect(() => malwareSchema.parse(invalidMalware)).toThrow();
            });

            it("should reject omittance of required values", () => {
                const { description, ...malwareWithoutDescription } = minimalMalware;
                expect(() => malwareSchema.parse(malwareWithoutDescription)).toThrow();
            });
        });

        describe('external_references', () => {
            it('should reject invalid values', () => {
                const invalidMalware: Malware = {
                    ...minimalMalware,
                    external_references: 'not-an-array' as unknown as ExternalReferences

                };
                expect(() => malwareSchema.parse(invalidMalware)).toThrow();
            });

            it('should reject omitted required values', () => {
                const { external_references, ...malwareWithoutExternalReferences } = minimalMalware;
                expect(() => malwareSchema.parse(malwareWithoutExternalReferences)).toThrow();
            });
        });

        describe('object_marking_refs', () => {
            it('should reject invalid values', () => {
                const invalidMalware: Malware = {
                    ...minimalMalware,
                    description: 123 as any
                };
                expect(() => malwareSchema.parse(invalidMalware)).toThrow();
            });

            it("should reject omittance of required values", () => {
                const { object_marking_refs, ...malwareWithoutObjectMarkingRefs } = minimalMalware;
                expect(() => malwareSchema.parse(malwareWithoutObjectMarkingRefs)).toThrow();
            });
        });

        describe('x_mitre_platforms', () => {
            it('should reject invalid values', () => {
                const invalidMalware: Malware = {
                    ...minimalMalware,
                    x_mitre_platforms: 123 as any
                };
                expect(() => malwareSchema.parse(invalidMalware)).toThrow();
            });

            it('should accept omitted optional values', () => {
                const { x_mitre_platforms, ...malwareWithoutPlatforms } = minimalMalware;
                expect(() => malwareSchema.parse(malwareWithoutPlatforms)).not.toThrow();
            });
        });

        describe('x_mitre_contributors', () => {
            it('should reject invalid values', () => {
                const invalidMalware: Malware = {
                    ...minimalMalware,
                    x_mitre_contributors: 'invalid string' as any
                };
                expect(() => malwareSchema.parse(invalidMalware)).toThrow();
            });

            it('should accept omitted optional values', () => {
                const { x_mitre_contributors, ...malwareWithoutContributors } = minimalMalware;
                expect(() => malwareSchema.parse(malwareWithoutContributors)).not.toThrow();
            });
        });

        describe('x_mitre_aliases', () => {
            it('should reject invalid values', () => {
                const invalidMalware: Malware = {
                    ...minimalMalware,
                    x_mitre_aliases: 123 as any
                };
                expect(() => malwareSchema.parse(invalidMalware)).toThrow();
            });

            it("should accept omitted optional values", () => {
                const { x_mitre_aliases, ...malwareWithoutXMitreAliases } = minimalMalware;
                expect(() => malwareSchema.parse(malwareWithoutXMitreAliases)).not.toThrow();
            });
        });

        describe('x_mitre_modified_by_ref', () => {
            it('should reject invalid values', () => {
                const invalidMalware: Malware = {
                    ...minimalMalware,
                    x_mitre_modified_by_ref: 'invalid-id' as any
                };
                expect(() => malwareSchema.parse(invalidMalware)).toThrow();
            });

            it("should reject omittance of required values", () => {
                const { x_mitre_modified_by_ref, ...malwareWithoutModifiedByRef } = minimalMalware;
                expect(() => malwareSchema.parse(malwareWithoutModifiedByRef)).toThrow();
            });
        });

        describe('x_mitre_domains', () => {
            it('should reject invalid values', () => {
                const invalidMalware: Malware = {
                    ...minimalMalware,
                    x_mitre_domains: 'not an array' as any
                };
                expect(() => malwareSchema.parse(invalidMalware)).toThrow();
            });

            it('should reject omitted required values', () => {
                const { x_mitre_domains, ...malwareWithoutDomains } = minimalMalware;
                expect(() => malwareSchema.parse(malwareWithoutDomains)).toThrow();
            });
        });
    });

    describe("Schema-Level Tests", () => {
        it('should reject unknown properties', () => {
            const malwareWithUnknownProperties = {
                ...minimalMalware,
                unknown_property: true
            } as Malware;
            expect(() => malwareSchema.parse(malwareWithUnknownProperties)).toThrow();
        });

        // Add any other schema-level tests...
    });

    describe("Edge Cases and Special Scenarios", () => {
        it("should handle special case X", () => {
            // Test any schema-specific special cases
        });

        // Add more edge case tests as needed...
    });

    describe('Validate All Objects', () => {
        it('should validate all objects in the global.attackData', () => {
            const errors: { malware: Malware; error: ZodError }[] = [];

            for (let malware of malwares) {
                try {
                    if (!malware.x_mitre_deprecated && !malware.revoked) {
                        malwareSchema.parse(malware);
                    }
                } catch (error) {
                    if (error instanceof ZodError) {
                        errors.push({ malware, error });
                    } else {
                        throw error; // Re-throw if it's not a ZodError
                    }
                }
            }

            if (errors.length > 0) {
                const errorReport = errors.map(({ malware, error }) => {
                    const malwareId = malware.external_references[0].external_id;
                    const malwareName = malware.name;
                    const errorMessages = error.errors.map(err =>
                        `    - ${err.path.join('.')}: ${err.message}`
                    ).join('\n');

                    return `
    Malware ID: ${malwareId}
    Malware Name: ${malwareName}
    Validation Errors:
    ${errorMessages}`;
                }).join('\n');

                console.warn(`The following ${errors.length} malware(s) failed validation:\n${errorReport}`);
            }

            // Log the number of errors found
            console.log(`Total malwares with validation errors: ${errors.length}`);

            // This expectation will always pass, but it gives us a way to surface the error count in the test results
            expect(true).toBe(true);
        });
    });
});
