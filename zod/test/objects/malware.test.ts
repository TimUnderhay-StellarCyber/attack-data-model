import { Name, StixCreatedTimestamp, StixModifiedTimestamp, StixSpecVersion, StixType, XMitreDomains } from "../../src/schemas/common";
import { malwareSchema } from "../../src/schemas/sdo/malware.schema";
import { v4 as uuidv4 } from 'uuid';

describe('malwareSchema', () => {

    // TODO rename malware to the appropriate object type
    let malwares: any[];

    beforeAll(() => {
        // TODO reset malwares to the appropriate object type
        malwares = global.attackData.objectsByType['malware'];
    });

    describe('Valid Inputs', () => {
        it('should accept minimal valid object (only required fields)', () => {
            // Test with only required fields
            const minimalMalware = {
                type: 'malware' as StixType,
                id: `malware--${uuidv4()}`,
                spec_version: '2.1' as StixSpecVersion,
                created_by_ref: `identity--${uuidv4()}`,
                created: "2017-05-31T21:32:29.203Z" as StixCreatedTimestamp,
                modified: "2021-02-09T13:58:23.806Z" as StixModifiedTimestamp,
                name: "HAMMERTOSS" as Name,
                description: "[HAMMERTOSS](https://attack.mitre.org/software/S0037) is a backdoor that was used by [APT29](https://attack.mitre.org/groups/G0016) in 2015. (Citation: FireEye APT29) (Citation: F-Secure The Dukes)",
                external_references: [
                  {
                    source_name: "mitre-attack",
                    url: "https://attack.mitre.org/software/S0037",
                    external_id: "S0037"
                  }
                ],
                object_marking_refs: [
                  "marking-definition--fa42a846-8d90-4e51-bc29-71d5b4802168"
                ],
                x_mitre_attack_spec_version: "2.1.0",
                x_mitre_domains: ["enterprise-attack"] as XMitreDomains,
                x_mitre_modified_by_ref: "identity--c78cb6e5-0c4b-4611-8297-d1b8b55e40b5",
                is_family: false,
                x_mitre_version: "1.2"
              };
              expect(() => malwareSchema.parse(minimalMalware)).not.toThrow();
            });

        it('should accept fully populated valid object (required + optional fields)', () => {
            // Test with all fields populated with valid, non-edge-case values
            const fullMalware = malwares.find(m =>
                m.revoked &&
                m.x_mitre_contributors &&
                m.x_mitre_platforms &&
                m.x_mitre_aliases
            );
            expect(fullMalware).toBeDefined();
            expect(() => malwareSchema.parse(fullMalware)).not.toThrow();
        });

        it('should accept fully populated valid object (required + optional fields)', () => {
            // Test with all fields populated with valid, non-edge-case values
            const fullMalware = malwares.find(m =>
                m.x_mitre_deprecated &&
                m.x_mitre_platforms &&
                m.x_mitre_aliases
            );
            expect(fullMalware).toBeDefined();
            expect(() => malwareSchema.parse(fullMalware)).not.toThrow();
        });
        // Add more valid input tests...
    });

    describe('Field-Specific Tests', () => {
        describe('id', () => {
            it('should accept valid values', () => {
                const validStixId = `malware--${uuidv4()}`;
                const validMalware = {
                    ...malwares[0],
                    id: validStixId
                };
                expect(() => malwareSchema.parse(validMalware)).not.toThrow();
            });

            it('should reject invalid values', () => {
                const invalidMalware = { ...malwares[0], id: 'invalid-id' };
                expect(() => malwareSchema.parse(invalidMalware)).toThrow();
            });

            it('should reject omittance of required values', () => {
                const { id, ...malwareWithoutId } = malwares[0];
                expect(() => malwareSchema.parse(malwareWithoutId)).toThrow();
            });
        });

        describe('is_family', () => {
            it('should accept valid values', () => {
                const validIsFamily = true;
                const validMalware = {
                    ...malwares[0],
                    is_family: validIsFamily
                };
                expect(() => malwareSchema.parse(validMalware)).not.toThrow();
            });

            it('should reject invalid values', () => {
                const invalidMalware = { ...malwares[0], is_family: 'invalid-is-family' };
                expect(() => malwareSchema.parse(invalidMalware)).toThrow();
            });

            it('should reject omittance of required values', () => {
                const { is_family, ...malwareWithoutIsFamily } = malwares[0];
                expect(() => malwareSchema.parse(malwareWithoutIsFamily)).toThrow();
            });
        });

        describe('created_by_ref', () => {
            it('should accept valid values', () => {
                const validCreatedByRef = `identity--${uuidv4()}`;
                const validMalware = {
                    ...malwares[0],
                    created_by_ref: validCreatedByRef
                };
                expect(() => malwareSchema.parse(validMalware)).not.toThrow();
            });

            it('should reject invalid values', () => {
                const invalidMalware = { ...malwares[0], created_by_ref: 'invalid-id' };
                expect(() => malwareSchema.parse(invalidMalware)).toThrow();
            });

            it('should reject omittance of required values', () => {
                const { created_by_ref, ...malwareWithoutIsFamily } = malwares[0];
                expect(() => malwareSchema.parse(malwareWithoutIsFamily)).toThrow();
            });
        });

        // Repeat for each field...
    });

    describe('Schema-Level Tests', () => {
        it('should reject unknown properties', () => {
        });

        // Add any other schema-level tests...
    });

    describe('Edge Cases and Special Scenarios', () => {
        it('should handle special case X', () => {
            // Test any schema-specific special cases
        });

        // Add more edge case tests as needed...
    });
});