import { z } from "zod";
import { StixTypeSchema } from "../common/stix-type";
import { SoftwareSchema } from "./software.schema";
import { createStixIdentifierSchema, KillChainPhaseSchema, StixIdentifierSchema, StixTimestampSchema } from "../common";

import '../../errors'; 


// Malware Schema
export const MalwareSchema = SoftwareSchema.extend({

    id: createStixIdentifierSchema(StixTypeSchema.enum.malware),

    type: z.literal(StixTypeSchema.enum.malware),

    is_family: z.boolean()
        .describe("Whether the object represents a malware family (if true) or a malware instance (if false)"),

    // NOTE: Technically this array should reference a well-defined vocabulary (malware-type-ov) but we don't use this field in ATT&CK Malware
    malware_types: z.array(z.string()).describe('A set of categorizations for the malware being described.').optional(),

    // Not used in ATT&CK Malware but defined in STIX
    aliases: z.array(z.string()).optional().describe("Alternative names used to identify this Campaign."),

    // Not used in ATT&CK Malware but defined in STIX
    kill_chain_phases: z.array(KillChainPhaseSchema).describe('The list of Kill Chain Phases for which this malware can be used.').optional(),

    first_seen: StixTimestampSchema
        .optional()
        .describe("The time that this malware instance or malware family was first seen."),

    last_seen: StixTimestampSchema
        .optional()
        .describe("The time that this malware family or malware instance was last seen."),

    operating_system_refs: z
        .array(StixIdentifierSchema)
        .describe('The operating systems that the malware family or malware instance is executable on. This applies to virtualized operating systems as well as those running on bare metal.')
        .optional(),

    // NOTE: Technically this array should reference a well-defined vocabulary (processor-architecture-ov) but we don't use this field in ATT&CK Malware
    architecture_execution_envs: z
        .array(z.string())
        .describe('The processor architectures (e.g., x86, ARM, etc.) that the malware instance or family is executable on.')
        .optional(),

    // NOTE: Technically this array should reference a well-defined vocabulary (implementation-language-ov) but we don't use this field in ATT&CK Malware
    implementation_languages: z
        .array(z.string())
        .describe('The programming language(s) used to implement the malware instance or family.')
        .optional(),

    // NOTE: Technically this array should reference a well-defined vocabulary (malware-capabilities-ov) but we don't use this field in ATT&CK Malware
    capabilities: z
        .array(z.string())
        .describe('Any of the capabilities identified for the malware instance or family.')
        .optional(),

    // Not used in ATT&CK Malware but defined in STIX
    sample_refs: z
        .array(StixIdentifierSchema)
        .optional()
        .describe('The sample_refs property specifies a list of identifiers of the SCO file or artifact objects associated with this malware instance(s) or family.')
});

// Define the type for Malware
export type Malware = z.infer<typeof MalwareSchema>;